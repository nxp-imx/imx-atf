#
# Copyright (c) 2015, 2016 Freescale Semiconductor, Inc.
# Copyright 2017-2021 NXP Semiconductors
#
# SPDX-License-Identifier: BSD-3-Clause
#
#
#------------------------------------------------------------------------------
#
# This file contains the basic architecture definitions that drive the build
#
# -----------------------------------------------------------------------------

CORE_TYPE	:=	a53

CACHE_LINE	:=	6

# set to GIC400 or GIC500
GIC		:=	GIC400

# set to CCI400 or CCN504 or CCN508
INTERCONNECT	:=	CCI400

# indicate layerscape chassis level - set to 3=LSCH3 or 2=LSCH2
CHASSIS		:=	2

# TZC IP Details TZC used is TZC380 or TZC400
TZC_ID		:=	TZC380

# CONSOLE Details available is NS16550 or PL011
CONSOLE		:=	NS16550

# Select the DDR PHY generation to be used
PLAT_DDR_PHY	:=      PHY_GEN1

PHYS_SYS	:=	64

# ddr controller - set to MMDC or NXP
DDRCNTLR	:=	NXP

# ddr phy - set to NXP or SNPS
DDRPHY		:=	NXP

# Area of OCRAM reserved by ROM code
NXP_ROM_RSVD	:=	0x5900

# Max Size of CSF header. Required to define BL2 TEXT LIMIT in soc.def
# Input to CST create_hdr_esbc tool
CSF_HDR_SZ	:=	0x3000

NXP_SFP_VER		:=	3_2

# In IMAGE_BL2, compile time flag for handling Cache coherency
# with CAAM for BL2 running from OCRAM
SEC_MEM_NON_COHERENT	:=	yes

# Defining the endianness for NXP ESDHC
NXP_ESDHC_ENDIANNESS	:=	BE

# Defining the endianness for NXP SFP
NXP_SFP_ENDIANNESS	:=	BE

# Defining the endianness for NXP GPIO
NXP_GPIO_ENDIANNESS	:=	BE

# Defining the endianness for NXP SNVS
NXP_SNVS_ENDIANNESS	:=	BE

# Defining the endianness for NXP CCSR GUR register
NXP_GUR_ENDIANNESS	:=	BE

# Defining the endianness for NXP FSPI register
NXP_FSPI_ENDIANNESS	:=	BE

# Defining the endianness for NXP SEC
NXP_SEC_ENDIANNESS	:=	BE

# Defining the endianness for NXP DDR
NXP_DDR_ENDIANNESS	:=	BE

# Defining the endianness for NXP QSPI
NXP_QSPI_ENDIANNESS	:=	BE

# Defining the endianness for NXP CCSR SCFG register
NXP_SCFG_ENDIANNESS	:=	BE

# Defining the endianness for NXP IFC
NXP_IFC_ENDIANNESS	:=	BE

# OCRAM MAP
OCRAM_START_ADDR	:=	0x10000000
OCRAM_SIZE		:=	0x20000

# BL2 binary is placed at  start of OCRAM.
# Also used by create_pbl.mk.
BL2_BASE		:=	0x10000000

# After BL2 bin, OCRAM is used by ROM Code:
# (OCRAM_START_ADDR + BL2_BIN_SIZE) ->  (NXP_ROM_RSVD - 1)

# After ROM Code, OCRAM is used by CSF header.
# (OCRAM_START_ADDR + BL2_TEXT_LIMIT + NXP_ROM_RSVD) -> (CSF_HDR_SZ - 1)

# BL2_HDR_LOC has to be (OCRAM_START_ADDR + OCRAM_SIZE - NXP_ROM_RSVD - CSF_HDR_SZ)
# This value should be greater than BL2_TEXT_LIMIT
# Input to CST create_hdr_isbc tool
BL2_HDR_LOC_HDR		?=	$(shell echo $$(( $(OCRAM_START_ADDR) + $(OCRAM_SIZE) - $(NXP_ROM_RSVD) - $(CSF_HDR_SZ))))
# Covert to HEX to be used by create_pbl.mk
BL2_HDR_LOC		:=	$$(echo "obase=16; ${BL2_HDR_LOC_HDR}" | bc)

# SoC ERRATAS to be enabled
#
# Core Errata
ERRATA_A53_855873	:=	1

# SoC ERRATAS to be enabled
ERRATA_SOC_A008850	:=	1
ERRATA_SOC_A010539	:=	1
ERRATA_PLAT_A009660	:=	1

# DDR Errata
ERRATA_DDR_A009663	:=	1
ERRATA_DDR_A009942	:=	1

ifneq (${CACHE_LINE},)
$(eval $(call add_define_val,PLATFORM_CACHE_LINE_SHIFT,${CACHE_LINE}))
$(eval CACHE_WRITEBACK_GRANULE=$(shell echo $$((1 << $(CACHE_LINE)))))
$(eval $(call add_define_val,CACHE_WRITEBACK_GRANULE,$(CACHE_WRITEBACK_GRANULE)))
endif

ifneq (${INTERCONNECT},)
$(eval $(call add_define,NXP_HAS_${INTERCONNECT}))
ICNNCT_ID := 0x420
$(eval $(call add_define,ICNNCT_ID))
endif

ifneq (${CHASSIS},)
$(info setting chssis)
$(eval $(call add_define,CONFIG_CHASSIS_${CHASSIS}))
endif

ifneq (${PLAT_DDR_PHY},)
$(eval $(call add_define,NXP_DDR_${PLAT_DDR_PHY}))
endif

ifneq (${PHYS_SYS},)
$(eval $(call add_define,CONFIG_PHYS_64BIT))
endif

ifneq (${CSF_HDR_SZ},)
$(eval $(call add_define_val,CSF_HDR_SZ,${CSF_HDR_SZ}))
endif

ifneq (${OCRAM_START_ADDR},)
$(eval $(call add_define_val,NXP_OCRAM_ADDR,${OCRAM_START_ADDR}))
endif

ifneq (${OCRAM_SIZE},)
$(eval $(call add_define_val,NXP_OCRAM_SIZE,${OCRAM_SIZE}))
endif

ifneq (${NXP_ROM_RSVD},)
$(eval $(call add_define_val,NXP_ROM_RSVD,${NXP_ROM_RSVD}))
endif

ifneq (${BL2_BASE},)
$(eval $(call add_define_val,BL2_BASE,${BL2_BASE}))
endif

ifeq (${SEC_MEM_NON_COHERENT},yes)
$(eval $(call add_define,SEC_MEM_NON_COHERENT))
endif

ifneq (${NXP_ESDHC_ENDIANNESS},)
$(eval $(call add_define,NXP_ESDHC_${NXP_ESDHC_ENDIANNESS}))
endif

ifneq (${NXP_SFP_VER},)
$(eval $(call add_define,NXP_SFP_VER_${NXP_SFP_VER}))
endif

ifneq (${NXP_SFP_ENDIANNESS},)
$(eval $(call add_define,NXP_SFP_${NXP_SFP_ENDIANNESS}))
endif

ifneq (${NXP_GPIO_ENDIANNESS},)
$(eval $(call add_define,NXP_GPIO_${NXP_GPIO_ENDIANNESS}))
endif

ifneq (${NXP_SNVS_ENDIANNESS},)
$(eval $(call add_define,NXP_SNVS_${NXP_SNVS_ENDIANNESS}))
endif

ifneq (${NXP_GUR_ENDIANNESS},)
$(eval $(call add_define,NXP_GUR_${NXP_GUR_ENDIANNESS}))
endif

ifneq (${NXP_FSPI_ENDIANNESS},)
$(eval $(call add_define,NXP_FSPI_${NXP_FSPI_ENDIANNESS}))
endif

# enable dynamic memory mapping
PLAT_XLAT_TABLES_DYNAMIC :=	1

ifneq (${NXP_SEC_ENDIANNESS},)
$(eval $(call add_define,NXP_SEC_${NXP_SEC_ENDIANNESS}))
endif

ifneq (${NXP_DDR_ENDIANNESS},)
$(eval $(call add_define,NXP_DDR_${NXP_DDR_ENDIANNESS}))
endif

ifneq (${NXP_QSPI_ENDIANNESS},)
$(eval $(call add_define,NXP_QSPI_${NXP_QSPI_ENDIANNESS}))
endif

ifneq (${NXP_SCFG_ENDIANNESS},)
$(eval $(call add_define,NXP_SCFG_${NXP_SCFG_ENDIANNESS}))
endif

ifneq (${NXP_IFC_ENDIANNESS},)
$(eval $(call add_define,NXP_IFC_${NXP_IFC_ENDIANNESS}))
endif

ifneq (${NXP_DDR_INTLV_256B},)
$(eval $(call add_define,NXP_DDR_INTLV_256B))
endif

ifneq (${PLAT_XLAT_TABLES_DYNAMIC},)
$(eval $(call add_define,PLAT_XLAT_TABLES_DYNAMIC))
endif
